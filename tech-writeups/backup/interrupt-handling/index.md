---
layout: default
title: interrupt-handling 
---

<a href="https://anish7610.github.io/technical-writeups" style="text-decoration: none;">← Back</a>


# Interrupt Handling and Context Switching in Kernel

Efficient multitasking and hardware responsiveness in modern operating systems are enabled by two key mechanisms in the kernel: **interrupt handling** and **context switching**. These are fundamental to how the kernel orchestrates processes, handles external events, and maintains CPU utilization.

---

## 1. What is an Interrupt?

An **interrupt** is a signal emitted by hardware or software to the processor, indicating an event that needs immediate attention.

### Types of Interrupts:

* **Hardware Interrupts:** Generated by devices (e.g., keyboard, network card, timer).
* **Software Interrupts:** Generated by programs (e.g., system calls, exceptions).

### Lifecycle of an Interrupt:

1. **Interrupt signal** is raised by a device or software.
2. The **CPU stops current execution**.
3. CPU consults the **Interrupt Descriptor Table (IDT)**.
4. Corresponding **Interrupt Service Routine (ISR)** is executed.
5. ISR completes, and control is returned (possibly to a different task).

---

## 2. Interrupt Handling in the Kernel

When an interrupt occurs:

1. **Interrupt Context**:

   * The kernel enters a special context where regular process scheduling is suspended.
   * It saves the state of the current task (registers, stack pointer).

2. **Top Half and Bottom Half**:

   * **Top Half (ISR):** Runs immediately; does minimal work (acknowledges interrupt).
   * **Bottom Half:** Deferred work using mechanisms like:

     * SoftIRQs
     * Tasklets
     * Workqueues

These bottom halves are scheduled to run later when it is safe to sleep or schedule tasks.

---

## 3. What is Context Switching?

**Context switching** is the act of saving the state of one process/thread and loading the state of another, allowing the CPU to switch between tasks.

### Types:

* **Process context switch** (between different processes)
* **Thread context switch** (between threads of the same or different processes)

### Steps in Context Switching:

1. **Save context** of current task (registers, program counter, stack pointer).
2. **Update kernel data structures** (task scheduler, CPU state).
3. **Load context** of the next task.
4. **Transfer control** to the new task.

---

## 4. Context Switching and the Scheduler

The **Linux scheduler** (CFS – Completely Fair Scheduler) decides which task runs next based on priorities and fairness.

Interrupts can:

* **Preempt the current task**, forcing a context switch.
* **Schedule deferred work**, which may also cause a switch.

### Involuntary Switch:

Triggered by:

* Timer interrupts (preemption)
* I/O wait
* Kernel yields

### Voluntary Switch:

Triggered by:

* Process calling `sleep()`, `wait()`, `sched_yield()`.

---

## 5. Interrupts and Context Switches in Practice

* Interrupts are **asynchronous**.
* Context switches are **synchronous** decisions by the scheduler.
* A context switch can be triggered as a result of an interrupt (e.g., timer interrupt leading to a new task being scheduled).

### Key Performance Metric:

* **High context switch rate** can degrade performance.
* **Interrupt storms** can overwhelm the system — mitigated using interrupt throttling and coalescing.

---

## Summary

| Feature           | Interrupt Handling              | Context Switching                   |
| ----------------- | ------------------------------- | ----------------------------------- |
| Trigger           | Asynchronous (HW/SW event)      | Scheduler decision or blocking call |
| Purpose           | Handle external/internal events | Switch execution between tasks      |
| Context           | Runs in interrupt context       | Runs in process/thread context      |
| Latency Critical? | Yes (especially in ISRs)        | No (usually)                        |
| Preemptive?       | Yes                             | Yes                                 |

---

## Conclusion

Interrupt handling and context switching are core kernel functions that allow responsive, multitasking operating systems. The balance between fast interrupt response and efficient task scheduling is crucial for system performance and reliability.
