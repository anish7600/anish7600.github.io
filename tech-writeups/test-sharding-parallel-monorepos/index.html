<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>test-sharding-parallel-monorepos</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/monokai.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1e1e2e;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            line-height: 1.6;
            overflow-x: hidden;
        }

        .matrix-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.05;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .back-link {
            color: #5bc0de;
            text-decoration: none;
            padding: 10px;
            display: block;
            transition: all 0.3s ease;
            margin-bottom: 20px;
            font-size: 1.1em;
        }

        .back-link:hover {
            color: #ff6b6b;
            text-shadow: 0 0 5px rgba(255, 107, 107, 0.5);
        }

        .terminal-window {
            background: #2a2a3a;
            border: 2px solid #5bc0de;
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 0 15px rgba(91, 192, 222, 0.2);
        }

        .terminal-header {
            background: #3a3a4a;
            padding: 10px;
            border-bottom: 1px solid #5bc0de;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .terminal-dots {
            display: flex;
            gap: 5px;
        }

        .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .dot.red { background: #ff5f56; }
        .dot.yellow { background: #ffbd2e; }
        .dot.green { background: #27ca3f; }

        .terminal-title {
            color: #a0a0a0;
            font-size: 14px;
        }

        .terminal-content {
            padding: 20px;
            padding: 20px 30px;
}

        .terminal-content pre {
            background: #1e1e2e;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }

        .terminal-content code {
            font-family: 'Courier New', monospace;
        }

        .terminal-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        .terminal-content th, .terminal-content td {
            border: 1px solid #5bc0de;
            padding: 10px;
            text-align: left;
        }

        .terminal-content th {
            background: #3a3a4a;
            color: #e0e0e0;
        }

        .terminal-content td {
            background: #2a2a3a;
        }

        .prompt {
            color: #5bc0de;
            margin-bottom: 10px;
        }

        .command {
            color: #ff6b6b;
        }

        h1 {
            color: #e0e0e0;
            font-weight: normal;
            text-shadow: 0 0 5px rgba(91, 192, 222, 0.3);
            font-size: 2.2em;
            text-align: center;
            margin-bottom: 20px;
        }

        h2, h3 {
            color: #e0e0e0;
            font-weight: normal;
            margin-bottom: 10px;
        }

        hr {
            border: 0;
            border-top: 1px solid #5bc0de;
            margin: 10px 0 20px 0;
            opacity: 0.5;
        }

        @keyframes glow {
            from { text-shadow: 0 0 5px rgba(91, 192, 222, 0.3); }
            to { text-shadow: 0 0 10px rgba(91, 192, 222, 0.5); }
        }

        .footer {
            text-align: center;
            padding: 20px;
            border-top: 1px solid #5bc0de;
            margin-top: 50px;
            color: #a0a0a0;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            
            .terminal-content {
                padding: 15px 20px;
            }

            .terminal-content ol {
                margin-left: 10px;
            }
}
            
            h1 {
                font-size: 1.8em;
                margin-bottom: 15px;
            }

            h2, h3 {
                margin-bottom: 8px;
            }

            hr {
                margin: 8px 0 15px 0;
            }

            .terminal-content table {
                font-size: 0.9em;
            }
        }

        .matrix-char {
            position: absolute;
            color: #5bc0de;
            font-family: monospace;
            font-size: 14px;
            animation: matrix-fall linear infinite;
        }

        @keyframes matrix-fall {
            0% { opacity: 1; transform: translateY(-100vh); }
            100% { opacity: 0; transform: translateY(100vh); }
        }
    
        .terminal-content ol {
            margin-left: 15px;
        }

        .terminal-content ol li {
            margin-bottom: 10px;
        }
</style>
</head>
<body>
    <canvas class="matrix-bg" id="matrixCanvas"></canvas>

    <div class="container">
        <a href="https://anish7600.github.io/tech-writeups" class="back-link">← Back</a>
        
        <h1>test-sharding-parallel-monorepos</h1>
        <hr>

        <div class="terminal-window">
            <div class="terminal-header">
                <div class="terminal-dots">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
                <div class="terminal-title">~/technical-writeups/test-sharding-parallel-monorepos/index.sh</div>
            </div>
            <div class="terminal-content">
                <p><a href="https://anish7600.github.io/technical-writeups" style="text-decoration: none;">← Back</a></p>
<h2>Test Sharding and Parallelization in Large Monorepos</h2><hr>
<p>In large-scale engineering organizations, monolithic repositories (monorepos) are often used to maintain codebases for multiple applications, libraries, or services. Running tests efficiently in such repositories becomes a major challenge, especially as the number of test cases and their execution time grow. <strong>Test sharding</strong> and <strong>parallelization</strong> are two critical strategies to scale test execution, reduce feedback cycles, and improve developer productivity.</p>
<hr />
<h3>The Challenge</h3><hr>
<p>In a monorepo setup:</p>
<ul>
<li>Tests can number in the tens or hundreds of thousands.</li>
<li>CI pipelines become bottlenecks due to long test durations.</li>
<li>Change impact is broad, causing many tests to rerun even for small diffs.</li>
</ul>
<hr />
<h3>Test Sharding: Divide and Conquer</h3><hr>
<p><strong>Test sharding</strong> refers to splitting the total test suite into smaller subsets (shards) which can be executed independently and in parallel.</p>
<h4>Key Strategies:</h4>
<ul>
<li><strong>Static Sharding</strong>: Predefined test splits based on test file names, directories, or modules.</li>
<li><strong>Dynamic Sharding</strong>: Tests are split at runtime based on historical duration data to balance execution time across shards.</li>
</ul>
<h4>Benefits:</h4>
<ul>
<li>Reduced test wall time by distributing work.</li>
<li>Easier to scale horizontally by increasing workers.</li>
<li>Enables large suites to fit within CI time limits.</li>
</ul>
<h4>Example (Pytest):</h4>
<pre class="codehilite"><code class="language-bash">pytest --dist=loadscope --tx 4*popen
</code></pre>

<hr />
<h3>Parallel Test Execution</h3><hr>
<p><strong>Parallelization</strong> complements sharding by running multiple tests simultaneously on different CPU cores or CI agents.</p>
<h4>Types of Parallelization:</h4>
<ol>
<li><strong>Intra-shard parallelism</strong> (e.g., using <code>pytest-xdist</code>)</li>
<li><strong>Inter-shard parallelism</strong> across CI jobs or containers</li>
</ol>
<h4>Challenges:</h4>
<ul>
<li>Race conditions in tests</li>
<li>Shared state or global fixtures</li>
<li>Port collisions in integration tests</li>
</ul>
<hr />
<h3>Tools and Frameworks</h3><hr>
<ul>
<li><strong>Bazel</strong>: Native support for test parallelization and caching</li>
<li><strong>pytest-xdist</strong>: Parallel test runner plugin</li>
<li><strong>JUnit + Gradle</strong>: <code>maxParallelForks</code>, <code>testLogging</code>, etc.</li>
<li><strong>TestNG (Java)</strong>: Allows defining test groups and parallelism at suite/class/method level</li>
<li><strong>GitHub Actions / GitLab CI</strong>: Matrix builds for sharding</li>
</ul>
<hr />
<h3>Test Splitting in CI/CD</h3><hr>
<p>CI systems like <strong>CircleCI</strong>, <strong>GitHub Actions</strong>, and <strong>GitLab CI</strong> provide:</p>
<ul>
<li><strong>Split by test timing</strong>: Based on historical test durations.</li>
<li><strong>Dynamic parallelism</strong>: Auto-adjusts shard sizes based on queue length and resources.</li>
<li><strong>Persistent caching</strong>: Avoids rerunning tests for unchanged code.</li>
</ul>
<p>Example (GitHub Actions matrix):</p>
<pre class="codehilite"><code class="language-yaml">strategy:
  matrix:
    shard: [1, 2, 3, 4]
  fail-fast: false
</code></pre>

<hr />
<h3>Best Practices</h3><hr>
<ul>
<li>Tag tests for selective runs (e.g., <code>@smoke</code>, <code>@integration</code>)</li>
<li>Collect and analyze test duration metrics</li>
<li>Use isolated environments per shard (e.g., containers)</li>
<li>Combine sharding with change-based test selection</li>
<li>Monitor and retry flaky shards independently</li>
</ul>
<hr />
<h3>Conclusion</h3><hr>
<p>Test sharding and parallelization are essential for maintaining agility and scalability in large monorepos. By carefully splitting test execution and using modern tooling, teams can drastically cut down CI times, reduce flakiness, and deliver faster, more reliable code.</p>
            </div>
        </div>

        <div class="footer">
            <div class="prompt">root@writeup:~$ <span class="command">echo "End of transmission"</span></div>
            <p>&copy; 2025 Anish. All rights reserved.</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize Highlight.js
            hljs.highlightAll();

            const canvas = document.getElementById('matrixCanvas');
            if (!canvas) {
                console.error('Canvas element not found');
                return;
            }
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('Canvas context not available');
                return;
            }

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!@#$%^&*()_+-=[]{}|;:,.<>?';
            const charArray = chars.split('');
            const fontSize = 14;
            const columns = Math.floor(canvas.width / fontSize);
            const drops = Array(columns).fill(1);

            function draw() {
                ctx.fillStyle = 'rgba(30, 30, 46, 0.04)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#5bc0de';
                ctx.font = `${fontSize}px monospace`;

                for (let i = 0; i < drops.length; i++) {
                    const text = charArray[Math.floor(Math.random() * charArray.length)];
                    ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }
            }

            setInterval(draw, 35);

            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });
        });
    </script>
</body>
</html>
